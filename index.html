<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eva Sánchez - Perfect Ripple Effect</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #ebebeb;
            color: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 0, 0, 0.3);
            font-size: 10px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">Eva Sánchez - Perfect Ripple</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', { 
            alpha: true, 
            premultipliedAlpha: false,
            antialias: true
        });

        if (!gl) {
            alert('WebGL not supported');
        }

        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = 1400 * dpr;
        canvas.height = 500 * dpr;
        canvas.style.width = '1400px';
        canvas.style.height = '500px';
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Create text with individual letter positions
        const text = 'Eva Sánchez';
        const textCanvas = document.createElement('canvas');
        const ctx = textCanvas.getContext('2d');
        textCanvas.width = 1400 * dpr;
        textCanvas.height = 500 * dpr;

        const fontSize = 160 * dpr;
        ctx.font = `900 ${fontSize}px -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#000000';

        // Measure and store letter positions
        const letterPositions = [];
        const centerX = textCanvas.width / 2;
        const centerY = textCanvas.height / 2;
        
        // Get total text width
        const totalWidth = ctx.measureText(text).width;
        let currentX = centerX - totalWidth / 2;

        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const charWidth = ctx.measureText(char).width;
            
            // Store letter info (in normalized 0-1 coordinates for canvas)
            letterPositions.push({
                char: char,
                x: currentX + charWidth / 2, // center of letter
                width: charWidth,
                normalizedX: (currentX + charWidth / 2) / textCanvas.width,
                normalizedWidth: charWidth / textCanvas.width
            });
            
            currentX += charWidth;
        }

        // Draw all letters
        ctx.fillText(text, centerX, centerY);

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        const vertexShaderSource = `
            attribute vec2 position;
            attribute vec2 uv;
            varying vec2 vUv;
            
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // FIXED - Complete blank vertical gap with perfect ripple effect
        const fragmentShaderSource = `
            precision highp float;
            
            uniform sampler2D tMap;
            uniform float uTime;
            uniform float uHoverIntensity;
            uniform float uHoverX;
            uniform float uHoverWidth;
            
            varying vec2 vUv;
            
            float ripple(float uv, float time, float prog) {
                float distance = length(((uv) + (time * 2.)));
                return tan(distance * (1.)) * (prog * -2.85);
            }
            
            void main() {
                // Smoother distance calculation from hovered letter
                float distanceFromHover = abs(vUv.x - uHoverX);
                float letterRange = uHoverWidth * 1.8;
                
                // Smooth quadratic falloff for better transitions
                float localIntensity = 0.0;
                if (distanceFromHover < letterRange) {
                    float normalizedDist = distanceFromHover / letterRange;
                    // Quadratic easing for smoother effect
                    localIntensity = uHoverIntensity * (1.1 - normalizedDist * normalizedDist);
                }
                
                // Ripple effect
                float rippleUV2 = ripple(vUv.x * 40.0, uHoverX, localIntensity) * (0.0018 * localIntensity);
                
                vec2 U = vec2(rippleUV2 + vUv.x, vUv.y);
                
                float distor = 1.0;
                
                float r = texture2D(tMap, vec2(U.x * distor, U.y / distor)).r;
                float g = texture2D(tMap, vec2(U.x, U.y)).g * (distor);
                float b = texture2D(tMap, vec2(U.x, U.y)).b * (distor + (1.6 * (distor - 1.0)));
                float a = texture2D(tMap, vec2(U.x, U.y)).a;
                
                gl_FragColor = vec4(r, g, b, a);
                
                // FIXED: Complete blank gap - increased multiplier for complete transparency
                // This creates a perfect vertical blank gap where the ripple occurs
                float gapIntensity = abs(rippleUV2) * 2.2;
                gl_FragColor.a -= gapIntensity;
                
                // Ensure complete transparency in gap area
                if (gapIntensity > 0.5) {
                    gl_FragColor.a = 0.0;
                }
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const positions = new Float32Array([
            -1, -1,  1, -1,  -1, 1,  1, 1
        ]);

        const uvs = new Float32Array([
            0, 1,  1, 1,  0, 0,  1, 0
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);

        const uvLocation = gl.getAttribLocation(program, 'uv');
        gl.enableVertexAttribArray(uvLocation);
        gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, 0, 0);

        const tMap = gl.getUniformLocation(program, 'tMap');
        const uTime = gl.getUniformLocation(program, 'uTime');
        const uHoverIntensity = gl.getUniformLocation(program, 'uHoverIntensity');
        const uHoverX = gl.getUniformLocation(program, 'uHoverX');
        const uHoverWidth = gl.getUniformLocation(program, 'uHoverWidth');

        let hoverIntensity = 1.0;
        let targetHoverIntensity = 1.0;
        let hoverX = 1.0;
        let targetHoverX = 1.0;
        let hoverWidth = 0.1;
        
        // Auto-play variables
        let autoPlayActive = true;
        let autoPlayStartTime = Date.now();
        const autoPlayDuration = 2500;
        
        setTimeout(() => {
            autoPlayActive = false;
            targetHoverIntensity = 0.0;
        }, autoPlayDuration);

        // Mouse tracking for per-letter detection
        let currentHoveredLetter = null;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / rect.width;
            const mouseY = (e.clientY - rect.top) / rect.height;
            
            if (!autoPlayActive) {
                // Find which letter is being hovered
                let foundLetter = null;
                for (let i = 0; i < letterPositions.length; i++) {
                    const letter = letterPositions[i];
                    const halfWidth = letter.normalizedWidth / 2;
                    
                    if (Math.abs(mouseX - letter.normalizedX) < halfWidth * 1.5) {
                        foundLetter = letter;
                        break;
                    }
                }
                
                if (foundLetter) {
                    currentHoveredLetter = foundLetter;
                    targetHoverIntensity = 1.0;
                    targetHoverX = foundLetter.normalizedX;
                    hoverWidth = foundLetter.normalizedWidth;
                } else {
                    currentHoveredLetter = null;
                    targetHoverIntensity = 0.0;
                }
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (!autoPlayActive) {
                currentHoveredLetter = null;
                targetHoverIntensity = 0.0;
            }
        });

        let time = 0;
        function animate() {
            time += 0.16;
            
            // Auto-play: sweep right to left
            if (autoPlayActive) {
                const elapsed = Date.now() - autoPlayStartTime;
                const progress = Math.min(elapsed / autoPlayDuration, 1.0);
                targetHoverX = 1.0 - progress;
                hoverWidth = 0.4;
            }
            
            // Smoother interpolation
            hoverX += (targetHoverX - hoverX) * 0.08;
            hoverIntensity += (targetHoverIntensity - hoverIntensity) * 0.06;

            gl.clearColor(0.92, 0.92, 0.92, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.uniform1i(tMap, 0);
            gl.uniform1f(uTime, time);
            gl.uniform1f(uHoverIntensity, hoverIntensity);
            gl.uniform1f(uHoverX, hoverX);
            gl.uniform1f(uHoverWidth, hoverWidth);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>