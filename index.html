<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eva SÃ¡nchez - VERTICAL</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #ebebeb;
            color: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        .info {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(0, 0, 0, 0.3);
            font-size: 10px;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="info">Hover - VERTICAL</div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl', { 
            alpha: true, 
            premultipliedAlpha: false,
            antialias: true
        });

        if (!gl) {
            alert('WebGL not supported');
        }

        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = 1400 * dpr;
        canvas.height = 500 * dpr;
        canvas.style.width = '1400px';
        canvas.style.height = '500px';
        gl.viewport(0, 0, canvas.width, canvas.height);

        const textCanvas = document.createElement('canvas');
        const ctx = textCanvas.getContext('2d');
        textCanvas.width = 1400 * dpr;
        textCanvas.height = 500 * dpr;

        ctx.fillStyle = '#000000';
        ctx.font = `900 ${160 * dpr}px -apple-system, BlinkMacSystemFont, 'Helvetica Neue', Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Eva Sanchez', textCanvas.width / 2, textCanvas.height / 2);

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        const vertexShaderSource = `
            attribute vec2 position;
            attribute vec2 uv;
            varying vec2 vUv;
            
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // SAME EFFECT - Just VERTICAL instead of horizontal
        const fragmentShaderSource = `
            precision highp float;
            
            uniform sampler2D tMap;
            uniform float uTime;
            uniform float uMouseT;
            uniform float uMouse;
            
            varying vec2 vUv;
            
            float ripple(float uv, float time, float prog) {
                float distance = length(((uv) + (time * 2.)));
                return tan(distance * (1.)) * (prog * -1.85);
            }
            
            void main() {
                // VERTICAL (using X coordinate instead of Y)
                float rippleUV2 = ripple(vUv.x, uMouse, uMouseT) * (0.0006 * uMouseT);
                
                // Apply ripple to X coordinate for VERTICAL effect
                vec2 U = vec2(rippleUV2 + vUv.x, vUv.y);
                
                float distor = 1.0;
                
                // Sample texture with displacement
                float r = texture2D(tMap, vec2(U.x * distor, U.y / distor)).r;
                float g = texture2D(tMap, vec2(U.x, U.y)).g * (distor);
                float b = texture2D(tMap, vec2(U.x, U.y)).b * (distor + (1.6 * (distor - 1.0)));
                float a = texture2D(tMap, vec2(U.x, U.y)).a;
                
                gl_FragColor = vec4(r, g, b, a);
                // Reduce alpha where ripple is strong
                gl_FragColor.a -= abs(rippleUV2) * (0.5);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program error:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const positions = new Float32Array([
            -1, -1,  1, -1,  -1, 1,  1, 1
        ]);

        const uvs = new Float32Array([
            0, 1,  1, 1,  0, 0,  1, 0
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);

        const uvLocation = gl.getAttribLocation(program, 'uv');
        gl.enableVertexAttribArray(uvLocation);
        gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, 0, 0);

        const tMap = gl.getUniformLocation(program, 'tMap');
        const uTime = gl.getUniformLocation(program, 'uTime');
        const uMouseT = gl.getUniformLocation(program, 'uMouseT');
        const uMouse = gl.getUniformLocation(program, 'uMouse');

        let mouse = 0.0;
        let targetMouse = 0.0;
        let mouseT = 0.0;
        let targetMouseT = 0.0;

        canvas.addEventListener('mouseenter', () => {
            targetMouseT = 1.0;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // X coordinate for VERTICAL effect
            targetMouse = (e.clientX - rect.left) / rect.width;
        });

        canvas.addEventListener('mouseleave', () => {
            targetMouseT = 0.0;
        });

        let time = 0;
        function animate() {
            time += 0.016;
            
            // Smooth interpolation
            mouse += (targetMouse - mouse) * 0.1;
            mouseT += (targetMouseT - mouseT) * 0.12;

            gl.clearColor(0.92, 0.92, 0.92, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.uniform1i(tMap, 0);
            gl.uniform1f(uTime, time);
            gl.uniform1f(uMouseT, mouseT);
            gl.uniform1f(uMouse, mouse);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>